#!/bin/bash

set -euo pipefail

build_images() {
    local cmd="${1}"

    if [ ! -n "${cmd}" ]; then
        for cmd in ./cmd/*; do
            build_image "${cmd}"
        done
    else
        # if we passed in a name to build, prepend the ./cmd path to it
        build_image "./cmd/${cmd}"
    fi
}

build_image() {
    local cmd="${1}"
    local command_name="$(basename "${cmd}")"

    OUTPUT_BIN=${OUTPUT_BIN:-command_name}
    GO_MAIN=${GO_MAIN:-command_name}

    printf "building ${command_name}\n"

    source "${cmd}"/build-info.sh

    docker_file=Dockerfile."${command_name}"
    include=scripts/Dockerfile.include
    if [ -f "${cmd}"/Dockerfile.include ]; then
        include="${cmd}"/Dockerfile.include
    fi

    cp scripts/Dockerfile.template "${docker_file}"
    cat "${include}" >> "${docker_file}"

    sed -i "s|__OUTPUTBIN__|${OUTPUT_BIN}|g" "${docker_file}"
    sed -i "s|__GOMAIN__|./cmd/${GO_MAIN}|g" "${docker_file}"
    sed -i "s|__DOCKER_CMD__|${DOCKER_CMD}|g" "${docker_file}"

    docker build -f "${docker_file}" -t "${DOCKER_REPO}:${VERSION}" .

    rm "${docker_file}"

    echo "${DOCKER_REPO}:${VERSION}" >> "${RELEASE_MANIFEST}"
}

# this ensures that we are in the correct directory context
cd "$(dirname "$0")"/..

build_images "$*"
